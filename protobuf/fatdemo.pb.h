// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fatdemo.proto

#ifndef PROTOBUF_fatdemo_2eproto__INCLUDED
#define PROTOBUF_fatdemo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "netmessages.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_fatdemo_2eproto();
void protobuf_AssignDesc_fatdemo_2eproto();
void protobuf_ShutdownFile_fatdemo_2eproto();

class MLDict;
class MLEvent;
class MLMatchState;
class MLRoundState;
class MLWeaponState;
class MLPlayerState;
class MLGameState;
class MLDemoHeader;
class MLTick;

enum EHitGroup {
  EHG_Generic = 0,
  EHG_Head = 1,
  EHG_Chest = 2,
  EHG_Stomach = 3,
  EHG_LeftArm = 4,
  EHG_RightArm = 5,
  EHG_LeftLeg = 6,
  EHG_RightLeg = 7,
  EHG_Gear = 8,
  EHG_Miss = 9
};
bool EHitGroup_IsValid(int value);
const EHitGroup EHitGroup_MIN = EHG_Generic;
const EHitGroup EHitGroup_MAX = EHG_Miss;
const int EHitGroup_ARRAYSIZE = EHitGroup_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHitGroup_descriptor();
inline const ::std::string& EHitGroup_Name(EHitGroup value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHitGroup_descriptor(), value);
}
inline bool EHitGroup_Parse(
    const ::std::string& name, EHitGroup* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitGroup>(
    EHitGroup_descriptor(), name, value);
}
enum ETeam {
  ET_Unknown = 0,
  ET_Spectator = 1,
  ET_Terrorist = 2,
  ET_CT = 3
};
bool ETeam_IsValid(int value);
const ETeam ETeam_MIN = ET_Unknown;
const ETeam ETeam_MAX = ET_CT;
const int ETeam_ARRAYSIZE = ETeam_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETeam_descriptor();
inline const ::std::string& ETeam_Name(ETeam value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETeam_descriptor(), value);
}
inline bool ETeam_Parse(
    const ::std::string& name, ETeam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETeam>(
    ETeam_descriptor(), name, value);
}
enum EWeaponType {
  EWT_Knife = 0,
  EWT_Pistol = 1,
  EWT_SubMachineGun = 2,
  EWT_Rifle = 3,
  EWT_Shotgun = 4,
  EWT_SniperRifle = 5,
  EWT_MachineGun = 6,
  EWT_C4 = 7,
  EWT_Grenade = 8,
  EWT_Equipment = 9,
  EWT_StackableItem = 10,
  EWT_Unknown = 11
};
bool EWeaponType_IsValid(int value);
const EWeaponType EWeaponType_MIN = EWT_Knife;
const EWeaponType EWeaponType_MAX = EWT_Unknown;
const int EWeaponType_ARRAYSIZE = EWeaponType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EWeaponType_descriptor();
inline const ::std::string& EWeaponType_Name(EWeaponType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EWeaponType_descriptor(), value);
}
inline bool EWeaponType_Parse(
    const ::std::string& name, EWeaponType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWeaponType>(
    EWeaponType_descriptor(), name, value);
}
// ===================================================================

class MLDict : public ::google::protobuf::Message {
 public:
  MLDict();
  virtual ~MLDict();

  MLDict(const MLDict& from);

  inline MLDict& operator=(const MLDict& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLDict& default_instance();

  void Swap(MLDict* other);

  // implements Message ----------------------------------------------

  MLDict* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLDict& from);
  void MergeFrom(const MLDict& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string val_string = 2;
  inline bool has_val_string() const;
  inline void clear_val_string();
  static const int kValStringFieldNumber = 2;
  inline const ::std::string& val_string() const;
  inline void set_val_string(const ::std::string& value);
  inline void set_val_string(const char* value);
  inline void set_val_string(const char* value, size_t size);
  inline ::std::string* mutable_val_string();
  inline ::std::string* release_val_string();
  inline void set_allocated_val_string(::std::string* val_string);

  // optional int32 val_int = 3;
  inline bool has_val_int() const;
  inline void clear_val_int();
  static const int kValIntFieldNumber = 3;
  inline ::google::protobuf::int32 val_int() const;
  inline void set_val_int(::google::protobuf::int32 value);

  // optional float val_float = 4;
  inline bool has_val_float() const;
  inline void clear_val_float();
  static const int kValFloatFieldNumber = 4;
  inline float val_float() const;
  inline void set_val_float(float value);

  // @@protoc_insertion_point(class_scope:MLDict)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val_string();
  inline void clear_has_val_string();
  inline void set_has_val_int();
  inline void clear_has_val_int();
  inline void set_has_val_float();
  inline void clear_has_val_float();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* val_string_;
  ::google::protobuf::int32 val_int_;
  float val_float_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLDict* default_instance_;
};
// -------------------------------------------------------------------

class MLEvent : public ::google::protobuf::Message {
 public:
  MLEvent();
  virtual ~MLEvent();

  MLEvent(const MLEvent& from);

  inline MLEvent& operator=(const MLEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLEvent& default_instance();

  void Swap(MLEvent* other);

  // implements Message ----------------------------------------------

  MLEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLEvent& from);
  void MergeFrom(const MLEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string event_name = 1;
  inline bool has_event_name() const;
  inline void clear_event_name();
  static const int kEventNameFieldNumber = 1;
  inline const ::std::string& event_name() const;
  inline void set_event_name(const ::std::string& value);
  inline void set_event_name(const char* value);
  inline void set_event_name(const char* value, size_t size);
  inline ::std::string* mutable_event_name();
  inline ::std::string* release_event_name();
  inline void set_allocated_event_name(::std::string* event_name);

  // repeated .MLDict data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::MLDict& data(int index) const;
  inline ::MLDict* mutable_data(int index);
  inline ::MLDict* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::MLDict >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::MLDict >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:MLEvent)
 private:
  inline void set_has_event_name();
  inline void clear_has_event_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* event_name_;
  ::google::protobuf::RepeatedPtrField< ::MLDict > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLEvent* default_instance_;
};
// -------------------------------------------------------------------

class MLMatchState : public ::google::protobuf::Message {
 public:
  MLMatchState();
  virtual ~MLMatchState();

  MLMatchState(const MLMatchState& from);

  inline MLMatchState& operator=(const MLMatchState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLMatchState& default_instance();

  void Swap(MLMatchState* other);

  // implements Message ----------------------------------------------

  MLMatchState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLMatchState& from);
  void MergeFrom(const MLMatchState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_mode = 1;
  inline bool has_game_mode() const;
  inline void clear_game_mode();
  static const int kGameModeFieldNumber = 1;
  inline const ::std::string& game_mode() const;
  inline void set_game_mode(const ::std::string& value);
  inline void set_game_mode(const char* value);
  inline void set_game_mode(const char* value, size_t size);
  inline ::std::string* mutable_game_mode();
  inline ::std::string* release_game_mode();
  inline void set_allocated_game_mode(::std::string* game_mode);

  // optional string phase = 2;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 2;
  inline const ::std::string& phase() const;
  inline void set_phase(const ::std::string& value);
  inline void set_phase(const char* value);
  inline void set_phase(const char* value, size_t size);
  inline ::std::string* mutable_phase();
  inline ::std::string* release_phase();
  inline void set_allocated_phase(::std::string* phase);

  // optional int32 round = 3;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 3;
  inline ::google::protobuf::int32 round() const;
  inline void set_round(::google::protobuf::int32 value);

  // optional int32 score_ct = 4;
  inline bool has_score_ct() const;
  inline void clear_score_ct();
  static const int kScoreCtFieldNumber = 4;
  inline ::google::protobuf::int32 score_ct() const;
  inline void set_score_ct(::google::protobuf::int32 value);

  // optional int32 score_t = 5;
  inline bool has_score_t() const;
  inline void clear_score_t();
  static const int kScoreTFieldNumber = 5;
  inline ::google::protobuf::int32 score_t() const;
  inline void set_score_t(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MLMatchState)
 private:
  inline void set_has_game_mode();
  inline void clear_has_game_mode();
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_score_ct();
  inline void clear_has_score_ct();
  inline void set_has_score_t();
  inline void clear_has_score_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* game_mode_;
  ::std::string* phase_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 score_ct_;
  ::google::protobuf::int32 score_t_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLMatchState* default_instance_;
};
// -------------------------------------------------------------------

class MLRoundState : public ::google::protobuf::Message {
 public:
  MLRoundState();
  virtual ~MLRoundState();

  MLRoundState(const MLRoundState& from);

  inline MLRoundState& operator=(const MLRoundState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLRoundState& default_instance();

  void Swap(MLRoundState* other);

  // implements Message ----------------------------------------------

  MLRoundState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLRoundState& from);
  void MergeFrom(const MLRoundState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline const ::std::string& phase() const;
  inline void set_phase(const ::std::string& value);
  inline void set_phase(const char* value);
  inline void set_phase(const char* value, size_t size);
  inline ::std::string* mutable_phase();
  inline ::std::string* release_phase();
  inline void set_allocated_phase(::std::string* phase);

  // optional .ETeam win_team = 2 [default = ET_Unknown];
  inline bool has_win_team() const;
  inline void clear_win_team();
  static const int kWinTeamFieldNumber = 2;
  inline ::ETeam win_team() const;
  inline void set_win_team(::ETeam value);

  // optional string bomb_state = 3;
  inline bool has_bomb_state() const;
  inline void clear_bomb_state();
  static const int kBombStateFieldNumber = 3;
  inline const ::std::string& bomb_state() const;
  inline void set_bomb_state(const ::std::string& value);
  inline void set_bomb_state(const char* value);
  inline void set_bomb_state(const char* value, size_t size);
  inline ::std::string* mutable_bomb_state();
  inline ::std::string* release_bomb_state();
  inline void set_allocated_bomb_state(::std::string* bomb_state);

  // @@protoc_insertion_point(class_scope:MLRoundState)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_win_team();
  inline void clear_has_win_team();
  inline void set_has_bomb_state();
  inline void clear_has_bomb_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* phase_;
  ::std::string* bomb_state_;
  int win_team_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLRoundState* default_instance_;
};
// -------------------------------------------------------------------

class MLWeaponState : public ::google::protobuf::Message {
 public:
  MLWeaponState();
  virtual ~MLWeaponState();

  MLWeaponState(const MLWeaponState& from);

  inline MLWeaponState& operator=(const MLWeaponState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLWeaponState& default_instance();

  void Swap(MLWeaponState* other);

  // implements Message ----------------------------------------------

  MLWeaponState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLWeaponState& from);
  void MergeFrom(const MLWeaponState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .EWeaponType type = 3 [default = EWT_Knife];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::EWeaponType type() const;
  inline void set_type(::EWeaponType value);

  // optional int32 ammo_clip = 4;
  inline bool has_ammo_clip() const;
  inline void clear_ammo_clip();
  static const int kAmmoClipFieldNumber = 4;
  inline ::google::protobuf::int32 ammo_clip() const;
  inline void set_ammo_clip(::google::protobuf::int32 value);

  // optional int32 ammo_clip_max = 5;
  inline bool has_ammo_clip_max() const;
  inline void clear_ammo_clip_max();
  static const int kAmmoClipMaxFieldNumber = 5;
  inline ::google::protobuf::int32 ammo_clip_max() const;
  inline void set_ammo_clip_max(::google::protobuf::int32 value);

  // optional int32 ammo_reserve = 6;
  inline bool has_ammo_reserve() const;
  inline void clear_ammo_reserve();
  static const int kAmmoReserveFieldNumber = 6;
  inline ::google::protobuf::int32 ammo_reserve() const;
  inline void set_ammo_reserve(::google::protobuf::int32 value);

  // optional string state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional float recoil_index = 8;
  inline bool has_recoil_index() const;
  inline void clear_recoil_index();
  static const int kRecoilIndexFieldNumber = 8;
  inline float recoil_index() const;
  inline void set_recoil_index(float value);

  // @@protoc_insertion_point(class_scope:MLWeaponState)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ammo_clip();
  inline void clear_has_ammo_clip();
  inline void set_has_ammo_clip_max();
  inline void clear_has_ammo_clip_max();
  inline void set_has_ammo_reserve();
  inline void clear_has_ammo_reserve();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_recoil_index();
  inline void clear_has_recoil_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 index_;
  int type_;
  ::google::protobuf::int32 ammo_clip_;
  ::google::protobuf::int32 ammo_clip_max_;
  ::std::string* state_;
  ::google::protobuf::int32 ammo_reserve_;
  float recoil_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLWeaponState* default_instance_;
};
// -------------------------------------------------------------------

class MLPlayerState : public ::google::protobuf::Message {
 public:
  MLPlayerState();
  virtual ~MLPlayerState();

  MLPlayerState(const MLPlayerState& from);

  inline MLPlayerState& operator=(const MLPlayerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLPlayerState& default_instance();

  void Swap(MLPlayerState* other);

  // implements Message ----------------------------------------------

  MLPlayerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLPlayerState& from);
  void MergeFrom(const MLPlayerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::int32 account_id() const;
  inline void set_account_id(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional int32 entindex = 3;
  inline bool has_entindex() const;
  inline void clear_entindex();
  static const int kEntindexFieldNumber = 3;
  inline ::google::protobuf::int32 entindex() const;
  inline void set_entindex(::google::protobuf::int32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string clan = 5;
  inline bool has_clan() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 5;
  inline const ::std::string& clan() const;
  inline void set_clan(const ::std::string& value);
  inline void set_clan(const char* value);
  inline void set_clan(const char* value, size_t size);
  inline ::std::string* mutable_clan();
  inline ::std::string* release_clan();
  inline void set_allocated_clan(::std::string* clan);

  // optional .ETeam team = 6 [default = ET_Unknown];
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 6;
  inline ::ETeam team() const;
  inline void set_team(::ETeam value);

  // optional .CMsgVector abspos = 7;
  inline bool has_abspos() const;
  inline void clear_abspos();
  static const int kAbsposFieldNumber = 7;
  inline const ::CMsgVector& abspos() const;
  inline ::CMsgVector* mutable_abspos();
  inline ::CMsgVector* release_abspos();
  inline void set_allocated_abspos(::CMsgVector* abspos);

  // optional .CMsgQAngle eyeangle = 8;
  inline bool has_eyeangle() const;
  inline void clear_eyeangle();
  static const int kEyeangleFieldNumber = 8;
  inline const ::CMsgQAngle& eyeangle() const;
  inline ::CMsgQAngle* mutable_eyeangle();
  inline ::CMsgQAngle* release_eyeangle();
  inline void set_allocated_eyeangle(::CMsgQAngle* eyeangle);

  // optional .CMsgVector eyeangle_fwd = 9;
  inline bool has_eyeangle_fwd() const;
  inline void clear_eyeangle_fwd();
  static const int kEyeangleFwdFieldNumber = 9;
  inline const ::CMsgVector& eyeangle_fwd() const;
  inline ::CMsgVector* mutable_eyeangle_fwd();
  inline ::CMsgVector* release_eyeangle_fwd();
  inline void set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd);

  // optional int32 health = 10;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 10;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // optional int32 armor = 11;
  inline bool has_armor() const;
  inline void clear_armor();
  static const int kArmorFieldNumber = 11;
  inline ::google::protobuf::int32 armor() const;
  inline void set_armor(::google::protobuf::int32 value);

  // optional float flashed = 12;
  inline bool has_flashed() const;
  inline void clear_flashed();
  static const int kFlashedFieldNumber = 12;
  inline float flashed() const;
  inline void set_flashed(float value);

  // optional float smoked = 13;
  inline bool has_smoked() const;
  inline void clear_smoked();
  static const int kSmokedFieldNumber = 13;
  inline float smoked() const;
  inline void set_smoked(float value);

  // optional int32 money = 14;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 14;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 round_kills = 15;
  inline bool has_round_kills() const;
  inline void clear_round_kills();
  static const int kRoundKillsFieldNumber = 15;
  inline ::google::protobuf::int32 round_kills() const;
  inline void set_round_kills(::google::protobuf::int32 value);

  // optional int32 round_killhs = 16;
  inline bool has_round_killhs() const;
  inline void clear_round_killhs();
  static const int kRoundKillhsFieldNumber = 16;
  inline ::google::protobuf::int32 round_killhs() const;
  inline void set_round_killhs(::google::protobuf::int32 value);

  // optional float burning = 17;
  inline bool has_burning() const;
  inline void clear_burning();
  static const int kBurningFieldNumber = 17;
  inline float burning() const;
  inline void set_burning(float value);

  // optional bool helmet = 18;
  inline bool has_helmet() const;
  inline void clear_helmet();
  static const int kHelmetFieldNumber = 18;
  inline bool helmet() const;
  inline void set_helmet(bool value);

  // optional bool defuse_kit = 19;
  inline bool has_defuse_kit() const;
  inline void clear_defuse_kit();
  static const int kDefuseKitFieldNumber = 19;
  inline bool defuse_kit() const;
  inline void set_defuse_kit(bool value);

  // repeated .MLWeaponState weapons = 20;
  inline int weapons_size() const;
  inline void clear_weapons();
  static const int kWeaponsFieldNumber = 20;
  inline const ::MLWeaponState& weapons(int index) const;
  inline ::MLWeaponState* mutable_weapons(int index);
  inline ::MLWeaponState* add_weapons();
  inline const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
      weapons() const;
  inline ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
      mutable_weapons();

  // @@protoc_insertion_point(class_scope:MLPlayerState)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_entindex();
  inline void clear_has_entindex();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clan();
  inline void clear_has_clan();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_abspos();
  inline void clear_has_abspos();
  inline void set_has_eyeangle();
  inline void clear_has_eyeangle();
  inline void set_has_eyeangle_fwd();
  inline void clear_has_eyeangle_fwd();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_flashed();
  inline void clear_has_flashed();
  inline void set_has_smoked();
  inline void clear_has_smoked();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_round_kills();
  inline void clear_has_round_kills();
  inline void set_has_round_killhs();
  inline void clear_has_round_killhs();
  inline void set_has_burning();
  inline void clear_has_burning();
  inline void set_has_helmet();
  inline void clear_has_helmet();
  inline void set_has_defuse_kit();
  inline void clear_has_defuse_kit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 account_id_;
  ::google::protobuf::int32 user_id_;
  ::std::string* name_;
  ::google::protobuf::int32 entindex_;
  int team_;
  ::std::string* clan_;
  ::CMsgVector* abspos_;
  ::CMsgQAngle* eyeangle_;
  ::CMsgVector* eyeangle_fwd_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 armor_;
  float flashed_;
  float smoked_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 round_kills_;
  ::google::protobuf::int32 round_killhs_;
  float burning_;
  ::google::protobuf::RepeatedPtrField< ::MLWeaponState > weapons_;
  bool helmet_;
  bool defuse_kit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLPlayerState* default_instance_;
};
// -------------------------------------------------------------------

class MLGameState : public ::google::protobuf::Message {
 public:
  MLGameState();
  virtual ~MLGameState();

  MLGameState(const MLGameState& from);

  inline MLGameState& operator=(const MLGameState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLGameState& default_instance();

  void Swap(MLGameState* other);

  // implements Message ----------------------------------------------

  MLGameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLGameState& from);
  void MergeFrom(const MLGameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MLMatchState match = 1;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 1;
  inline const ::MLMatchState& match() const;
  inline ::MLMatchState* mutable_match();
  inline ::MLMatchState* release_match();
  inline void set_allocated_match(::MLMatchState* match);

  // optional .MLRoundState round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline const ::MLRoundState& round() const;
  inline ::MLRoundState* mutable_round();
  inline ::MLRoundState* release_round();
  inline void set_allocated_round(::MLRoundState* round);

  // repeated .MLPlayerState players = 3;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 3;
  inline const ::MLPlayerState& players(int index) const;
  inline ::MLPlayerState* mutable_players(int index);
  inline ::MLPlayerState* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:MLGameState)
 private:
  inline void set_has_match();
  inline void clear_has_match();
  inline void set_has_round();
  inline void clear_has_round();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MLMatchState* match_;
  ::MLRoundState* round_;
  ::google::protobuf::RepeatedPtrField< ::MLPlayerState > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLGameState* default_instance_;
};
// -------------------------------------------------------------------

class MLDemoHeader : public ::google::protobuf::Message {
 public:
  MLDemoHeader();
  virtual ~MLDemoHeader();

  MLDemoHeader(const MLDemoHeader& from);

  inline MLDemoHeader& operator=(const MLDemoHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLDemoHeader& default_instance();

  void Swap(MLDemoHeader* other);

  // implements Message ----------------------------------------------

  MLDemoHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLDemoHeader& from);
  void MergeFrom(const MLDemoHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_name = 1;
  inline bool has_map_name() const;
  inline void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& map_name() const;
  inline void set_map_name(const ::std::string& value);
  inline void set_map_name(const char* value);
  inline void set_map_name(const char* value, size_t size);
  inline ::std::string* mutable_map_name();
  inline ::std::string* release_map_name();
  inline void set_allocated_map_name(::std::string* map_name);

  // optional int32 tick_rate = 2;
  inline bool has_tick_rate() const;
  inline void clear_tick_rate();
  static const int kTickRateFieldNumber = 2;
  inline ::google::protobuf::int32 tick_rate() const;
  inline void set_tick_rate(::google::protobuf::int32 value);

  // optional uint32 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 steam_universe = 4;
  inline bool has_steam_universe() const;
  inline void clear_steam_universe();
  static const int kSteamUniverseFieldNumber = 4;
  inline ::google::protobuf::uint32 steam_universe() const;
  inline void set_steam_universe(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MLDemoHeader)
 private:
  inline void set_has_map_name();
  inline void clear_has_map_name();
  inline void set_has_tick_rate();
  inline void clear_has_tick_rate();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_steam_universe();
  inline void clear_has_steam_universe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_name_;
  ::google::protobuf::int32 tick_rate_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 steam_universe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLDemoHeader* default_instance_;
};
// -------------------------------------------------------------------

class MLTick : public ::google::protobuf::Message {
 public:
  MLTick();
  virtual ~MLTick();

  MLTick(const MLTick& from);

  inline MLTick& operator=(const MLTick& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLTick& default_instance();

  void Swap(MLTick* other);

  // implements Message ----------------------------------------------

  MLTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MLTick& from);
  void MergeFrom(const MLTick& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 tick_count = 1;
  inline bool has_tick_count() const;
  inline void clear_tick_count();
  static const int kTickCountFieldNumber = 1;
  inline ::google::protobuf::int32 tick_count() const;
  inline void set_tick_count(::google::protobuf::int32 value);

  // optional .MLGameState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::MLGameState& state() const;
  inline ::MLGameState* mutable_state();
  inline ::MLGameState* release_state();
  inline void set_allocated_state(::MLGameState* state);

  // repeated .MLEvent events = 3;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 3;
  inline const ::MLEvent& events(int index) const;
  inline ::MLEvent* mutable_events(int index);
  inline ::MLEvent* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::MLEvent >*
      mutable_events();

  // @@protoc_insertion_point(class_scope:MLTick)
 private:
  inline void set_has_tick_count();
  inline void clear_has_tick_count();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MLGameState* state_;
  ::google::protobuf::RepeatedPtrField< ::MLEvent > events_;
  ::google::protobuf::int32 tick_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_fatdemo_2eproto();
  friend void protobuf_AssignDesc_fatdemo_2eproto();
  friend void protobuf_ShutdownFile_fatdemo_2eproto();

  void InitAsDefaultInstance();
  static MLTick* default_instance_;
};
// ===================================================================


// ===================================================================

// MLDict

// optional string key = 1;
inline bool MLDict::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLDict::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLDict::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLDict::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MLDict::key() const {
  return *key_;
}
inline void MLDict::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MLDict::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MLDict::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLDict::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* MLDict::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLDict::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string val_string = 2;
inline bool MLDict::has_val_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLDict::set_has_val_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLDict::clear_has_val_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLDict::clear_val_string() {
  if (val_string_ != &::google::protobuf::internal::kEmptyString) {
    val_string_->clear();
  }
  clear_has_val_string();
}
inline const ::std::string& MLDict::val_string() const {
  return *val_string_;
}
inline void MLDict::set_val_string(const ::std::string& value) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(value);
}
inline void MLDict::set_val_string(const char* value) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(value);
}
inline void MLDict::set_val_string(const char* value, size_t size) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLDict::mutable_val_string() {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  return val_string_;
}
inline ::std::string* MLDict::release_val_string() {
  clear_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = val_string_;
    val_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLDict::set_allocated_val_string(::std::string* val_string) {
  if (val_string_ != &::google::protobuf::internal::kEmptyString) {
    delete val_string_;
  }
  if (val_string) {
    set_has_val_string();
    val_string_ = val_string;
  } else {
    clear_has_val_string();
    val_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 val_int = 3;
inline bool MLDict::has_val_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLDict::set_has_val_int() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLDict::clear_has_val_int() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLDict::clear_val_int() {
  val_int_ = 0;
  clear_has_val_int();
}
inline ::google::protobuf::int32 MLDict::val_int() const {
  return val_int_;
}
inline void MLDict::set_val_int(::google::protobuf::int32 value) {
  set_has_val_int();
  val_int_ = value;
}

// optional float val_float = 4;
inline bool MLDict::has_val_float() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLDict::set_has_val_float() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLDict::clear_has_val_float() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLDict::clear_val_float() {
  val_float_ = 0;
  clear_has_val_float();
}
inline float MLDict::val_float() const {
  return val_float_;
}
inline void MLDict::set_val_float(float value) {
  set_has_val_float();
  val_float_ = value;
}

// -------------------------------------------------------------------

// MLEvent

// optional string event_name = 1;
inline bool MLEvent::has_event_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLEvent::set_has_event_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLEvent::clear_has_event_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLEvent::clear_event_name() {
  if (event_name_ != &::google::protobuf::internal::kEmptyString) {
    event_name_->clear();
  }
  clear_has_event_name();
}
inline const ::std::string& MLEvent::event_name() const {
  return *event_name_;
}
inline void MLEvent::set_event_name(const ::std::string& value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
}
inline void MLEvent::set_event_name(const char* value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
}
inline void MLEvent::set_event_name(const char* value, size_t size) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLEvent::mutable_event_name() {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    event_name_ = new ::std::string;
  }
  return event_name_;
}
inline ::std::string* MLEvent::release_event_name() {
  clear_has_event_name();
  if (event_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_name_;
    event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLEvent::set_allocated_event_name(::std::string* event_name) {
  if (event_name_ != &::google::protobuf::internal::kEmptyString) {
    delete event_name_;
  }
  if (event_name) {
    set_has_event_name();
    event_name_ = event_name;
  } else {
    clear_has_event_name();
    event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MLDict data = 2;
inline int MLEvent::data_size() const {
  return data_.size();
}
inline void MLEvent::clear_data() {
  data_.Clear();
}
inline const ::MLDict& MLEvent::data(int index) const {
  return data_.Get(index);
}
inline ::MLDict* MLEvent::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::MLDict* MLEvent::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MLDict >&
MLEvent::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::MLDict >*
MLEvent::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// MLMatchState

// optional string game_mode = 1;
inline bool MLMatchState::has_game_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLMatchState::set_has_game_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLMatchState::clear_has_game_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLMatchState::clear_game_mode() {
  if (game_mode_ != &::google::protobuf::internal::kEmptyString) {
    game_mode_->clear();
  }
  clear_has_game_mode();
}
inline const ::std::string& MLMatchState::game_mode() const {
  return *game_mode_;
}
inline void MLMatchState::set_game_mode(const ::std::string& value) {
  set_has_game_mode();
  if (game_mode_ == &::google::protobuf::internal::kEmptyString) {
    game_mode_ = new ::std::string;
  }
  game_mode_->assign(value);
}
inline void MLMatchState::set_game_mode(const char* value) {
  set_has_game_mode();
  if (game_mode_ == &::google::protobuf::internal::kEmptyString) {
    game_mode_ = new ::std::string;
  }
  game_mode_->assign(value);
}
inline void MLMatchState::set_game_mode(const char* value, size_t size) {
  set_has_game_mode();
  if (game_mode_ == &::google::protobuf::internal::kEmptyString) {
    game_mode_ = new ::std::string;
  }
  game_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLMatchState::mutable_game_mode() {
  set_has_game_mode();
  if (game_mode_ == &::google::protobuf::internal::kEmptyString) {
    game_mode_ = new ::std::string;
  }
  return game_mode_;
}
inline ::std::string* MLMatchState::release_game_mode() {
  clear_has_game_mode();
  if (game_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_mode_;
    game_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLMatchState::set_allocated_game_mode(::std::string* game_mode) {
  if (game_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete game_mode_;
  }
  if (game_mode) {
    set_has_game_mode();
    game_mode_ = game_mode;
  } else {
    clear_has_game_mode();
    game_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phase = 2;
inline bool MLMatchState::has_phase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLMatchState::set_has_phase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLMatchState::clear_has_phase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLMatchState::clear_phase() {
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    phase_->clear();
  }
  clear_has_phase();
}
inline const ::std::string& MLMatchState::phase() const {
  return *phase_;
}
inline void MLMatchState::set_phase(const ::std::string& value) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(value);
}
inline void MLMatchState::set_phase(const char* value) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(value);
}
inline void MLMatchState::set_phase(const char* value, size_t size) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLMatchState::mutable_phase() {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  return phase_;
}
inline ::std::string* MLMatchState::release_phase() {
  clear_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phase_;
    phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLMatchState::set_allocated_phase(::std::string* phase) {
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    delete phase_;
  }
  if (phase) {
    set_has_phase();
    phase_ = phase;
  } else {
    clear_has_phase();
    phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 round = 3;
inline bool MLMatchState::has_round() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLMatchState::set_has_round() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLMatchState::clear_has_round() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLMatchState::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 MLMatchState::round() const {
  return round_;
}
inline void MLMatchState::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
}

// optional int32 score_ct = 4;
inline bool MLMatchState::has_score_ct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLMatchState::set_has_score_ct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLMatchState::clear_has_score_ct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLMatchState::clear_score_ct() {
  score_ct_ = 0;
  clear_has_score_ct();
}
inline ::google::protobuf::int32 MLMatchState::score_ct() const {
  return score_ct_;
}
inline void MLMatchState::set_score_ct(::google::protobuf::int32 value) {
  set_has_score_ct();
  score_ct_ = value;
}

// optional int32 score_t = 5;
inline bool MLMatchState::has_score_t() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLMatchState::set_has_score_t() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLMatchState::clear_has_score_t() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MLMatchState::clear_score_t() {
  score_t_ = 0;
  clear_has_score_t();
}
inline ::google::protobuf::int32 MLMatchState::score_t() const {
  return score_t_;
}
inline void MLMatchState::set_score_t(::google::protobuf::int32 value) {
  set_has_score_t();
  score_t_ = value;
}

// -------------------------------------------------------------------

// MLRoundState

// optional string phase = 1;
inline bool MLRoundState::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLRoundState::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLRoundState::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLRoundState::clear_phase() {
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    phase_->clear();
  }
  clear_has_phase();
}
inline const ::std::string& MLRoundState::phase() const {
  return *phase_;
}
inline void MLRoundState::set_phase(const ::std::string& value) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(value);
}
inline void MLRoundState::set_phase(const char* value) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(value);
}
inline void MLRoundState::set_phase(const char* value, size_t size) {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  phase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLRoundState::mutable_phase() {
  set_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    phase_ = new ::std::string;
  }
  return phase_;
}
inline ::std::string* MLRoundState::release_phase() {
  clear_has_phase();
  if (phase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phase_;
    phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLRoundState::set_allocated_phase(::std::string* phase) {
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    delete phase_;
  }
  if (phase) {
    set_has_phase();
    phase_ = phase;
  } else {
    clear_has_phase();
    phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ETeam win_team = 2 [default = ET_Unknown];
inline bool MLRoundState::has_win_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLRoundState::set_has_win_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLRoundState::clear_has_win_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLRoundState::clear_win_team() {
  win_team_ = 0;
  clear_has_win_team();
}
inline ::ETeam MLRoundState::win_team() const {
  return static_cast< ::ETeam >(win_team_);
}
inline void MLRoundState::set_win_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  set_has_win_team();
  win_team_ = value;
}

// optional string bomb_state = 3;
inline bool MLRoundState::has_bomb_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLRoundState::set_has_bomb_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLRoundState::clear_has_bomb_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLRoundState::clear_bomb_state() {
  if (bomb_state_ != &::google::protobuf::internal::kEmptyString) {
    bomb_state_->clear();
  }
  clear_has_bomb_state();
}
inline const ::std::string& MLRoundState::bomb_state() const {
  return *bomb_state_;
}
inline void MLRoundState::set_bomb_state(const ::std::string& value) {
  set_has_bomb_state();
  if (bomb_state_ == &::google::protobuf::internal::kEmptyString) {
    bomb_state_ = new ::std::string;
  }
  bomb_state_->assign(value);
}
inline void MLRoundState::set_bomb_state(const char* value) {
  set_has_bomb_state();
  if (bomb_state_ == &::google::protobuf::internal::kEmptyString) {
    bomb_state_ = new ::std::string;
  }
  bomb_state_->assign(value);
}
inline void MLRoundState::set_bomb_state(const char* value, size_t size) {
  set_has_bomb_state();
  if (bomb_state_ == &::google::protobuf::internal::kEmptyString) {
    bomb_state_ = new ::std::string;
  }
  bomb_state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLRoundState::mutable_bomb_state() {
  set_has_bomb_state();
  if (bomb_state_ == &::google::protobuf::internal::kEmptyString) {
    bomb_state_ = new ::std::string;
  }
  return bomb_state_;
}
inline ::std::string* MLRoundState::release_bomb_state() {
  clear_has_bomb_state();
  if (bomb_state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bomb_state_;
    bomb_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLRoundState::set_allocated_bomb_state(::std::string* bomb_state) {
  if (bomb_state_ != &::google::protobuf::internal::kEmptyString) {
    delete bomb_state_;
  }
  if (bomb_state) {
    set_has_bomb_state();
    bomb_state_ = bomb_state;
  } else {
    clear_has_bomb_state();
    bomb_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MLWeaponState

// optional int32 index = 1;
inline bool MLWeaponState::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLWeaponState::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLWeaponState::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLWeaponState::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 MLWeaponState::index() const {
  return index_;
}
inline void MLWeaponState::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional string name = 2;
inline bool MLWeaponState::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLWeaponState::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLWeaponState::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLWeaponState::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MLWeaponState::name() const {
  return *name_;
}
inline void MLWeaponState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MLWeaponState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MLWeaponState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLWeaponState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MLWeaponState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLWeaponState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .EWeaponType type = 3 [default = EWT_Knife];
inline bool MLWeaponState::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLWeaponState::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLWeaponState::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLWeaponState::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::EWeaponType MLWeaponState::type() const {
  return static_cast< ::EWeaponType >(type_);
}
inline void MLWeaponState::set_type(::EWeaponType value) {
  assert(::EWeaponType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 ammo_clip = 4;
inline bool MLWeaponState::has_ammo_clip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLWeaponState::set_has_ammo_clip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLWeaponState::clear_has_ammo_clip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLWeaponState::clear_ammo_clip() {
  ammo_clip_ = 0;
  clear_has_ammo_clip();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_clip() const {
  return ammo_clip_;
}
inline void MLWeaponState::set_ammo_clip(::google::protobuf::int32 value) {
  set_has_ammo_clip();
  ammo_clip_ = value;
}

// optional int32 ammo_clip_max = 5;
inline bool MLWeaponState::has_ammo_clip_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLWeaponState::set_has_ammo_clip_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLWeaponState::clear_has_ammo_clip_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MLWeaponState::clear_ammo_clip_max() {
  ammo_clip_max_ = 0;
  clear_has_ammo_clip_max();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_clip_max() const {
  return ammo_clip_max_;
}
inline void MLWeaponState::set_ammo_clip_max(::google::protobuf::int32 value) {
  set_has_ammo_clip_max();
  ammo_clip_max_ = value;
}

// optional int32 ammo_reserve = 6;
inline bool MLWeaponState::has_ammo_reserve() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MLWeaponState::set_has_ammo_reserve() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MLWeaponState::clear_has_ammo_reserve() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MLWeaponState::clear_ammo_reserve() {
  ammo_reserve_ = 0;
  clear_has_ammo_reserve();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_reserve() const {
  return ammo_reserve_;
}
inline void MLWeaponState::set_ammo_reserve(::google::protobuf::int32 value) {
  set_has_ammo_reserve();
  ammo_reserve_ = value;
}

// optional string state = 7;
inline bool MLWeaponState::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MLWeaponState::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MLWeaponState::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MLWeaponState::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& MLWeaponState::state() const {
  return *state_;
}
inline void MLWeaponState::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void MLWeaponState::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void MLWeaponState::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLWeaponState::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* MLWeaponState::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLWeaponState::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float recoil_index = 8;
inline bool MLWeaponState::has_recoil_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MLWeaponState::set_has_recoil_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MLWeaponState::clear_has_recoil_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MLWeaponState::clear_recoil_index() {
  recoil_index_ = 0;
  clear_has_recoil_index();
}
inline float MLWeaponState::recoil_index() const {
  return recoil_index_;
}
inline void MLWeaponState::set_recoil_index(float value) {
  set_has_recoil_index();
  recoil_index_ = value;
}

// -------------------------------------------------------------------

// MLPlayerState

// optional int32 account_id = 1;
inline bool MLPlayerState::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLPlayerState::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLPlayerState::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLPlayerState::clear_account_id() {
  account_id_ = 0;
  clear_has_account_id();
}
inline ::google::protobuf::int32 MLPlayerState::account_id() const {
  return account_id_;
}
inline void MLPlayerState::set_account_id(::google::protobuf::int32 value) {
  set_has_account_id();
  account_id_ = value;
}

// optional int32 user_id = 2;
inline bool MLPlayerState::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLPlayerState::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLPlayerState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLPlayerState::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 MLPlayerState::user_id() const {
  return user_id_;
}
inline void MLPlayerState::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional int32 entindex = 3;
inline bool MLPlayerState::has_entindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLPlayerState::set_has_entindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLPlayerState::clear_has_entindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLPlayerState::clear_entindex() {
  entindex_ = 0;
  clear_has_entindex();
}
inline ::google::protobuf::int32 MLPlayerState::entindex() const {
  return entindex_;
}
inline void MLPlayerState::set_entindex(::google::protobuf::int32 value) {
  set_has_entindex();
  entindex_ = value;
}

// optional string name = 4;
inline bool MLPlayerState::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLPlayerState::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLPlayerState::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLPlayerState::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MLPlayerState::name() const {
  return *name_;
}
inline void MLPlayerState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MLPlayerState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MLPlayerState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLPlayerState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MLPlayerState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLPlayerState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clan = 5;
inline bool MLPlayerState::has_clan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLPlayerState::set_has_clan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLPlayerState::clear_has_clan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MLPlayerState::clear_clan() {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    clan_->clear();
  }
  clear_has_clan();
}
inline const ::std::string& MLPlayerState::clan() const {
  return *clan_;
}
inline void MLPlayerState::set_clan(const ::std::string& value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void MLPlayerState::set_clan(const char* value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void MLPlayerState::set_clan(const char* value, size_t size) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLPlayerState::mutable_clan() {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  return clan_;
}
inline ::std::string* MLPlayerState::release_clan() {
  clear_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_;
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLPlayerState::set_allocated_clan(::std::string* clan) {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_;
  }
  if (clan) {
    set_has_clan();
    clan_ = clan;
  } else {
    clear_has_clan();
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ETeam team = 6 [default = ET_Unknown];
inline bool MLPlayerState::has_team() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MLPlayerState::set_has_team() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MLPlayerState::clear_has_team() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MLPlayerState::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::ETeam MLPlayerState::team() const {
  return static_cast< ::ETeam >(team_);
}
inline void MLPlayerState::set_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  set_has_team();
  team_ = value;
}

// optional .CMsgVector abspos = 7;
inline bool MLPlayerState::has_abspos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MLPlayerState::set_has_abspos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MLPlayerState::clear_has_abspos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MLPlayerState::clear_abspos() {
  if (abspos_ != NULL) abspos_->::CMsgVector::Clear();
  clear_has_abspos();
}
inline const ::CMsgVector& MLPlayerState::abspos() const {
  return abspos_ != NULL ? *abspos_ : *default_instance_->abspos_;
}
inline ::CMsgVector* MLPlayerState::mutable_abspos() {
  set_has_abspos();
  if (abspos_ == NULL) abspos_ = new ::CMsgVector;
  return abspos_;
}
inline ::CMsgVector* MLPlayerState::release_abspos() {
  clear_has_abspos();
  ::CMsgVector* temp = abspos_;
  abspos_ = NULL;
  return temp;
}
inline void MLPlayerState::set_allocated_abspos(::CMsgVector* abspos) {
  delete abspos_;
  abspos_ = abspos;
  if (abspos) {
    set_has_abspos();
  } else {
    clear_has_abspos();
  }
}

// optional .CMsgQAngle eyeangle = 8;
inline bool MLPlayerState::has_eyeangle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MLPlayerState::set_has_eyeangle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MLPlayerState::clear_has_eyeangle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MLPlayerState::clear_eyeangle() {
  if (eyeangle_ != NULL) eyeangle_->::CMsgQAngle::Clear();
  clear_has_eyeangle();
}
inline const ::CMsgQAngle& MLPlayerState::eyeangle() const {
  return eyeangle_ != NULL ? *eyeangle_ : *default_instance_->eyeangle_;
}
inline ::CMsgQAngle* MLPlayerState::mutable_eyeangle() {
  set_has_eyeangle();
  if (eyeangle_ == NULL) eyeangle_ = new ::CMsgQAngle;
  return eyeangle_;
}
inline ::CMsgQAngle* MLPlayerState::release_eyeangle() {
  clear_has_eyeangle();
  ::CMsgQAngle* temp = eyeangle_;
  eyeangle_ = NULL;
  return temp;
}
inline void MLPlayerState::set_allocated_eyeangle(::CMsgQAngle* eyeangle) {
  delete eyeangle_;
  eyeangle_ = eyeangle;
  if (eyeangle) {
    set_has_eyeangle();
  } else {
    clear_has_eyeangle();
  }
}

// optional .CMsgVector eyeangle_fwd = 9;
inline bool MLPlayerState::has_eyeangle_fwd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MLPlayerState::set_has_eyeangle_fwd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MLPlayerState::clear_has_eyeangle_fwd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MLPlayerState::clear_eyeangle_fwd() {
  if (eyeangle_fwd_ != NULL) eyeangle_fwd_->::CMsgVector::Clear();
  clear_has_eyeangle_fwd();
}
inline const ::CMsgVector& MLPlayerState::eyeangle_fwd() const {
  return eyeangle_fwd_ != NULL ? *eyeangle_fwd_ : *default_instance_->eyeangle_fwd_;
}
inline ::CMsgVector* MLPlayerState::mutable_eyeangle_fwd() {
  set_has_eyeangle_fwd();
  if (eyeangle_fwd_ == NULL) eyeangle_fwd_ = new ::CMsgVector;
  return eyeangle_fwd_;
}
inline ::CMsgVector* MLPlayerState::release_eyeangle_fwd() {
  clear_has_eyeangle_fwd();
  ::CMsgVector* temp = eyeangle_fwd_;
  eyeangle_fwd_ = NULL;
  return temp;
}
inline void MLPlayerState::set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd) {
  delete eyeangle_fwd_;
  eyeangle_fwd_ = eyeangle_fwd;
  if (eyeangle_fwd) {
    set_has_eyeangle_fwd();
  } else {
    clear_has_eyeangle_fwd();
  }
}

// optional int32 health = 10;
inline bool MLPlayerState::has_health() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MLPlayerState::set_has_health() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MLPlayerState::clear_has_health() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MLPlayerState::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 MLPlayerState::health() const {
  return health_;
}
inline void MLPlayerState::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
}

// optional int32 armor = 11;
inline bool MLPlayerState::has_armor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MLPlayerState::set_has_armor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MLPlayerState::clear_has_armor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MLPlayerState::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline ::google::protobuf::int32 MLPlayerState::armor() const {
  return armor_;
}
inline void MLPlayerState::set_armor(::google::protobuf::int32 value) {
  set_has_armor();
  armor_ = value;
}

// optional float flashed = 12;
inline bool MLPlayerState::has_flashed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MLPlayerState::set_has_flashed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MLPlayerState::clear_has_flashed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MLPlayerState::clear_flashed() {
  flashed_ = 0;
  clear_has_flashed();
}
inline float MLPlayerState::flashed() const {
  return flashed_;
}
inline void MLPlayerState::set_flashed(float value) {
  set_has_flashed();
  flashed_ = value;
}

// optional float smoked = 13;
inline bool MLPlayerState::has_smoked() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MLPlayerState::set_has_smoked() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MLPlayerState::clear_has_smoked() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MLPlayerState::clear_smoked() {
  smoked_ = 0;
  clear_has_smoked();
}
inline float MLPlayerState::smoked() const {
  return smoked_;
}
inline void MLPlayerState::set_smoked(float value) {
  set_has_smoked();
  smoked_ = value;
}

// optional int32 money = 14;
inline bool MLPlayerState::has_money() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MLPlayerState::set_has_money() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MLPlayerState::clear_has_money() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MLPlayerState::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 MLPlayerState::money() const {
  return money_;
}
inline void MLPlayerState::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 round_kills = 15;
inline bool MLPlayerState::has_round_kills() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MLPlayerState::set_has_round_kills() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MLPlayerState::clear_has_round_kills() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MLPlayerState::clear_round_kills() {
  round_kills_ = 0;
  clear_has_round_kills();
}
inline ::google::protobuf::int32 MLPlayerState::round_kills() const {
  return round_kills_;
}
inline void MLPlayerState::set_round_kills(::google::protobuf::int32 value) {
  set_has_round_kills();
  round_kills_ = value;
}

// optional int32 round_killhs = 16;
inline bool MLPlayerState::has_round_killhs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MLPlayerState::set_has_round_killhs() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MLPlayerState::clear_has_round_killhs() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MLPlayerState::clear_round_killhs() {
  round_killhs_ = 0;
  clear_has_round_killhs();
}
inline ::google::protobuf::int32 MLPlayerState::round_killhs() const {
  return round_killhs_;
}
inline void MLPlayerState::set_round_killhs(::google::protobuf::int32 value) {
  set_has_round_killhs();
  round_killhs_ = value;
}

// optional float burning = 17;
inline bool MLPlayerState::has_burning() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MLPlayerState::set_has_burning() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MLPlayerState::clear_has_burning() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MLPlayerState::clear_burning() {
  burning_ = 0;
  clear_has_burning();
}
inline float MLPlayerState::burning() const {
  return burning_;
}
inline void MLPlayerState::set_burning(float value) {
  set_has_burning();
  burning_ = value;
}

// optional bool helmet = 18;
inline bool MLPlayerState::has_helmet() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MLPlayerState::set_has_helmet() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MLPlayerState::clear_has_helmet() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MLPlayerState::clear_helmet() {
  helmet_ = false;
  clear_has_helmet();
}
inline bool MLPlayerState::helmet() const {
  return helmet_;
}
inline void MLPlayerState::set_helmet(bool value) {
  set_has_helmet();
  helmet_ = value;
}

// optional bool defuse_kit = 19;
inline bool MLPlayerState::has_defuse_kit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MLPlayerState::set_has_defuse_kit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MLPlayerState::clear_has_defuse_kit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MLPlayerState::clear_defuse_kit() {
  defuse_kit_ = false;
  clear_has_defuse_kit();
}
inline bool MLPlayerState::defuse_kit() const {
  return defuse_kit_;
}
inline void MLPlayerState::set_defuse_kit(bool value) {
  set_has_defuse_kit();
  defuse_kit_ = value;
}

// repeated .MLWeaponState weapons = 20;
inline int MLPlayerState::weapons_size() const {
  return weapons_.size();
}
inline void MLPlayerState::clear_weapons() {
  weapons_.Clear();
}
inline const ::MLWeaponState& MLPlayerState::weapons(int index) const {
  return weapons_.Get(index);
}
inline ::MLWeaponState* MLPlayerState::mutable_weapons(int index) {
  return weapons_.Mutable(index);
}
inline ::MLWeaponState* MLPlayerState::add_weapons() {
  return weapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
MLPlayerState::weapons() const {
  return weapons_;
}
inline ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
MLPlayerState::mutable_weapons() {
  return &weapons_;
}

// -------------------------------------------------------------------

// MLGameState

// optional .MLMatchState match = 1;
inline bool MLGameState::has_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLGameState::set_has_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLGameState::clear_has_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLGameState::clear_match() {
  if (match_ != NULL) match_->::MLMatchState::Clear();
  clear_has_match();
}
inline const ::MLMatchState& MLGameState::match() const {
  return match_ != NULL ? *match_ : *default_instance_->match_;
}
inline ::MLMatchState* MLGameState::mutable_match() {
  set_has_match();
  if (match_ == NULL) match_ = new ::MLMatchState;
  return match_;
}
inline ::MLMatchState* MLGameState::release_match() {
  clear_has_match();
  ::MLMatchState* temp = match_;
  match_ = NULL;
  return temp;
}
inline void MLGameState::set_allocated_match(::MLMatchState* match) {
  delete match_;
  match_ = match;
  if (match) {
    set_has_match();
  } else {
    clear_has_match();
  }
}

// optional .MLRoundState round = 2;
inline bool MLGameState::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLGameState::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLGameState::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLGameState::clear_round() {
  if (round_ != NULL) round_->::MLRoundState::Clear();
  clear_has_round();
}
inline const ::MLRoundState& MLGameState::round() const {
  return round_ != NULL ? *round_ : *default_instance_->round_;
}
inline ::MLRoundState* MLGameState::mutable_round() {
  set_has_round();
  if (round_ == NULL) round_ = new ::MLRoundState;
  return round_;
}
inline ::MLRoundState* MLGameState::release_round() {
  clear_has_round();
  ::MLRoundState* temp = round_;
  round_ = NULL;
  return temp;
}
inline void MLGameState::set_allocated_round(::MLRoundState* round) {
  delete round_;
  round_ = round;
  if (round) {
    set_has_round();
  } else {
    clear_has_round();
  }
}

// repeated .MLPlayerState players = 3;
inline int MLGameState::players_size() const {
  return players_.size();
}
inline void MLGameState::clear_players() {
  players_.Clear();
}
inline const ::MLPlayerState& MLGameState::players(int index) const {
  return players_.Get(index);
}
inline ::MLPlayerState* MLGameState::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::MLPlayerState* MLGameState::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
MLGameState::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
MLGameState::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// MLDemoHeader

// optional string map_name = 1;
inline bool MLDemoHeader::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLDemoHeader::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLDemoHeader::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLDemoHeader::clear_map_name() {
  if (map_name_ != &::google::protobuf::internal::kEmptyString) {
    map_name_->clear();
  }
  clear_has_map_name();
}
inline const ::std::string& MLDemoHeader::map_name() const {
  return *map_name_;
}
inline void MLDemoHeader::set_map_name(const ::std::string& value) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void MLDemoHeader::set_map_name(const char* value) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void MLDemoHeader::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MLDemoHeader::mutable_map_name() {
  set_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    map_name_ = new ::std::string;
  }
  return map_name_;
}
inline ::std::string* MLDemoHeader::release_map_name() {
  clear_has_map_name();
  if (map_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_name_;
    map_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MLDemoHeader::set_allocated_map_name(::std::string* map_name) {
  if (map_name_ != &::google::protobuf::internal::kEmptyString) {
    delete map_name_;
  }
  if (map_name) {
    set_has_map_name();
    map_name_ = map_name;
  } else {
    clear_has_map_name();
    map_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 tick_rate = 2;
inline bool MLDemoHeader::has_tick_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLDemoHeader::set_has_tick_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLDemoHeader::clear_has_tick_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLDemoHeader::clear_tick_rate() {
  tick_rate_ = 0;
  clear_has_tick_rate();
}
inline ::google::protobuf::int32 MLDemoHeader::tick_rate() const {
  return tick_rate_;
}
inline void MLDemoHeader::set_tick_rate(::google::protobuf::int32 value) {
  set_has_tick_rate();
  tick_rate_ = value;
}

// optional uint32 version = 3;
inline bool MLDemoHeader::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLDemoHeader::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLDemoHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLDemoHeader::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MLDemoHeader::version() const {
  return version_;
}
inline void MLDemoHeader::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional uint32 steam_universe = 4;
inline bool MLDemoHeader::has_steam_universe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLDemoHeader::set_has_steam_universe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLDemoHeader::clear_has_steam_universe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLDemoHeader::clear_steam_universe() {
  steam_universe_ = 0u;
  clear_has_steam_universe();
}
inline ::google::protobuf::uint32 MLDemoHeader::steam_universe() const {
  return steam_universe_;
}
inline void MLDemoHeader::set_steam_universe(::google::protobuf::uint32 value) {
  set_has_steam_universe();
  steam_universe_ = value;
}

// -------------------------------------------------------------------

// MLTick

// optional int32 tick_count = 1;
inline bool MLTick::has_tick_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLTick::set_has_tick_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLTick::clear_has_tick_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLTick::clear_tick_count() {
  tick_count_ = 0;
  clear_has_tick_count();
}
inline ::google::protobuf::int32 MLTick::tick_count() const {
  return tick_count_;
}
inline void MLTick::set_tick_count(::google::protobuf::int32 value) {
  set_has_tick_count();
  tick_count_ = value;
}

// optional .MLGameState state = 2;
inline bool MLTick::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLTick::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLTick::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLTick::clear_state() {
  if (state_ != NULL) state_->::MLGameState::Clear();
  clear_has_state();
}
inline const ::MLGameState& MLTick::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::MLGameState* MLTick::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::MLGameState;
  return state_;
}
inline ::MLGameState* MLTick::release_state() {
  clear_has_state();
  ::MLGameState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void MLTick::set_allocated_state(::MLGameState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// repeated .MLEvent events = 3;
inline int MLTick::events_size() const {
  return events_.size();
}
inline void MLTick::clear_events() {
  events_.Clear();
}
inline const ::MLEvent& MLTick::events(int index) const {
  return events_.Get(index);
}
inline ::MLEvent* MLTick::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::MLEvent* MLTick::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
MLTick::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::MLEvent >*
MLTick::mutable_events() {
  return &events_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHitGroup>() {
  return ::EHitGroup_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETeam>() {
  return ::ETeam_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EWeaponType>() {
  return ::EWeaponType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fatdemo_2eproto__INCLUDED
